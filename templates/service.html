{% extends "base.html" %}

{% block title %}Service - OutfitPoseEditor{% endblock %}

{% block content %}
<div class="text-center">
  <h1 class="title">OutfitPoseEditor</h1>
  <p class="lead">Upload an image and choose which part to change!</p>
</div>

<!-- Step 1: Image Upload and Segmentation -->
<form id="upload-form">
  <div class="form-group">
    <label for="file-input">Choose an image or drag & drop:</label>
    <div id="drop-zone" class="drop-zone" onclick="document.getElementById('file-input').click();">
      <p id="drop-zone-text">Drag & drop your image here, or click to select</p>
      <input type="file" id="file-input" class="file-input" name="file" accept="image/*" required>
    </div>
  </div>
  <button type="submit" class="btn btn-primary btn-block">Upload Image</button>
</form>

<!-- Loading Spinner -->
<div class="mt-3 text-center" id="progress" style="display:none;">
  <div class="spinner-border text-primary" role="status">
    <span class="sr-only">Processing...</span>
  </div>
  <p class="mt-2">Processing your image, please wait...</p>
</div>

<!-- Step 2: Display Masks for Selection -->
<div class="result-box mt-5 text-center" id="segmentation-result" style="display:none;">
  <h3>Segmented Image</h3>
  <div id="segmented-image-container" style="position: relative; display: inline-block;">
    <!-- Original Image -->
{#    <img id="segmented-image" src="" alt="Segmented Image" class="img-fluid mt-3" style="max-width: 100%;" />#}

    <!-- Mask Overlays (will be appended here) -->
    <div id="masks-container" style="position: absolute; top: 0; left: 0;"></div>
  </div>
  <p>Select a part of the image to transform:</p>
  <div id="mask-buttons-container" class="mt-3"></div>

  <div class="form-group mt-3">
    <label for="transformation-prompt">Describe the transformation:</label>
    <textarea class="form-control" id="transformation-prompt" rows="3"
              placeholder="e.g., Change hair color to blonde"></textarea>
  </div>
  <button id="apply-transformation" class="btn btn-success mt-3" style="display:none;">Apply Transformation</button>
</div>

<!-- Result Box for Edited Image -->
<div class="result-box mt-5 text-center" id="edited-image-result" style="display:none;">
  <h3>Transformation Result</h3>
  <img id="transformed-image" src="" alt="Transformed Image" class="img-fluid mt-3"/>
  <a id="download-btn" class="btn-download mt-3" href="#" download="transformed-image.jpg">
    <img src="static/img/btnDownload2.png" alt="Download Image" />
  </a>
</div>

<script>
// Variables for managing upload and transformation
let uploadId = ''; // To track the unique upload directory
let selectedMask = null; // Track the selected mask

// Color map for each segment label (RGB format)
const colorMap = {
  0: [0, 0, 0], // Background: Black
  1: [128, 0, 0], // Hat: Maroon
  2: [255, 165, 0], // Hair: Orange
  3: [255, 215, 0], // Sunglasses: Gold
  4: [0, 128, 0], // Upper-clothes: Green
  5: [0, 0, 255], // Skirt: Blue
  6: [75, 0, 130], // Pants: Indigo
  7: [238, 130, 238], // Dress: Violet
  8: [255, 20, 147], // Belt: Deep Pink
  9: [139, 69, 19], // Left-shoe: Saddle Brown
  10: [210, 105, 30], // Right-shoe: Chocolate
  11: [255, 192, 203], // Face: Pink
  12: [0, 255, 127], // Left-leg: Spring Green
  13: [32, 178, 170], // Right-leg: Light Sea Green
  14: [70, 130, 180], // Left-arm: Steel Blue
  15: [135, 206, 250], // Right-arm: Light Sky Blue
  16: [240, 230, 140], // Bag: Khaki
  17: [255, 0, 255] // Scarf: Magenta
};

// Drag & Drop functionality
const dropZone = document.getElementById('drop-zone');
const fileInput = document.getElementById('file-input');
const dropZoneText = document.getElementById('drop-zone-text');

dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropZone.classList.add('dragover');
});

dropZone.addEventListener('dragleave', () => {
  dropZone.classList.remove('dragover');
});

dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  dropZone.classList.remove('dragover');

  if (e.dataTransfer.files.length) {
    fileInput.files = e.dataTransfer.files;
    updateDropZoneText(fileInput.files[0].name); // Update the drop zone text
  }
});

fileInput.addEventListener('change', () => {
  if (fileInput.files.length) {
    updateDropZoneText(fileInput.files[0].name);  // Update the drop zone text
  }
});

function updateDropZoneText(filename) {
  dropZoneText.textContent = `File selected: ${filename}`;
}

// Handle form submission with AJAX
document.getElementById('upload-form').addEventListener('submit', async function (e) {
  e.preventDefault();
  const formData = new FormData();
  formData.append('file', fileInput.files[0]);

  // Show the progress indicator
  document.getElementById('progress').style.display = 'block';

  // Hide previous results
  document.getElementById('segmentation-result').style.display = 'none';

  try {
    const response = await fetch('/upload', {
      method: 'POST',
      body: formData
    });

    if (response.ok) {
      const data = await response.json(); // Expecting JSON with mask paths

      // Hide the progress indicator
      document.getElementById('progress').style.display = 'none';

      // Store the upload ID for later transformation
      uploadId = data.upload_id;

      // Display the segmented image container
      document.getElementById('segmentation-result').style.display = 'block';

      // Display the masks over the original image
      const masksContainer = document.getElementById('masks-container');
      const maskButtonsContainer = document.getElementById('mask-buttons-container');
      masksContainer.innerHTML = ''; // Clear existing masks
      maskButtonsContainer.innerHTML = ''; // Clear existing buttons

      // Display each mask with a button to select it
      for (const [classId, maskPath] of Object.entries(data.segmented_masks)) {
        // Create an image for the mask overlay
        const maskImg = new Image();
        maskImg.src = `/${maskPath}`; // Use relative path from the response
        maskImg.className = 'mask-overlay';
        maskImg.style.position = 'absolute';
        maskImg.style.top = 0;
        maskImg.style.left = 0;
        maskImg.style.opacity = 0.9; // Make the mask semi-transparent
        maskImg.style.pointerEvents = 'none'; // Ensure it doesn't block clicks
        maskImg.dataset.classId = classId;

        maskImg.onload = () => {
          // Apply transparency filter to the mask
          applyTransparencyToMask(maskImg, classId);
        };

        // Append the mask to the container
        masksContainer.appendChild(maskImg);

        // Create a button to select the mask
        const maskButton = document.createElement('button');
        maskButton.className = 'btn btn-outline-primary mr-2 mt-2';
        maskButton.innerText = `Select ${classId}`;
        maskButton.onclick = function() {
          // Select the mask on button click
          selectMask(classId);
        };
        maskButtonsContainer.appendChild(maskButton);
      }

      // Show the transformation button
      document.getElementById('apply-transformation').style.display = 'block';
    } else {
      alert('Error: Something went wrong with the upload.');
    }
  } catch (error) {
    console.error('Error:', error);
    document.getElementById('progress').style.display = 'none'; // Hide loading spinner
    alert('Error: Failed to process the request.');
  }
});

// Function to select a mask
function selectMask(classId) {
  // Update the selected mask and visually highlight it
  selectedMask = classId;

  // Highlight the selected mask
  document.querySelectorAll('.mask-overlay').forEach(img => {
    img.style.border = img.dataset.classId === classId ? '3px solid red' : 'none';
  });

  console.log(`Selected mask class: ${classId}`);
}

// Function to make the mask transparent on black pixels and color on white pixels
function applyTransparencyToMask(maskImage, classId) {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');

  // Set canvas dimensions to match the mask image
  canvas.width = maskImage.width;
  canvas.height = maskImage.height;

  // Draw the mask image onto the canvas
  context.drawImage(maskImage, 0, 0);

  // Get image data from canvas
  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  // Get the RGB color for the classId from the colorMap
  const [redColor, greenColor, blueColor] = colorMap[classId];

  // Loop through each pixel to modify transparency and color based on mask value
  for (let i = 0; i < data.length; i += 4) {
    const red = data[i];
    const green = data[i + 1];
    const blue = data[i + 2];

    // If the pixel is black (0,0,0), make it fully transparent
    if (red === 0 && green === 0 && blue === 0) {
      data[i + 3] = 0; // Set alpha to 0 (fully transparent)
    } else {
      // Apply color based on the classId from the colorMap
      data[i] = redColor;
      data[i + 1] = greenColor;
      data[i + 2] = blueColor;
      data[i + 3] = 200; // Set alpha to 200 (semi-transparent)
    }
  }

  // Update canvas with new image data
  context.putImageData(imageData, 0, 0);

  // Set the source of the mask image to the modified canvas
  maskImage.src = canvas.toDataURL();
}

// Handle apply transformation button click
document.getElementById('apply-transformation').addEventListener('click', function() {
  const prompt = document.getElementById('transformation-prompt').value;

  if (!selectedMask || !prompt) {
    alert('Please select a segment and provide a transformation prompt.');
    return;
  }

  // Perform transformation based on selected mask and prompt
  fetch('/transform', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      upload_id: uploadId,
      segment: selectedMask,
      prompt: prompt
    })
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      // Set transformed image source and display
      document.getElementById('transformed-image').src = data.transformed_image_url;
      document.getElementById('edited-image-result').style.display = 'block';

      // Update download button
      const downloadBtn = document.getElementById('download-btn');
      downloadBtn.href = data.transformed_image_url;
    } else {
      alert(data.message);
    }
  })
  .catch(error => {
    console.error('Error:', error);
    alert('An error occurred while applying the transformation.');
  });
});
</script>
{% endblock %}
